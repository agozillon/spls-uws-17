<!DOCTYPE html>
<html>

<head>
<link rel="stylesheet" type="text/css" href="CSS/base.css" media="screen" />
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
</head>

<body>
<div class="container">

<div class="row">
<div class="col-lg-9 col-md-7 col-sm-5" style="padding-top: 12px;">
	<h1>Scottish Programming Languages Seminar (SPLS) </h1>
	<h2>University of the West of Scotland, Paisley Campus, 26th June 2017 </h2>
</div>

<div class="col-lg-2 col-md-2 col-sm-2">
	<a href="https://www.uws.ac.uk/home/"><img src="Images/uwsicon.png" alt="UniIcon"></a>
	<a href="http://www.sicsa.ac.uk/"><img src="Images/sicsa-logo.jpg" style="margin-left: 10px; width: 8cm;"alt="SicsaIcon"></a>
</div>

</div>

<div class="row col-lg-12 col-md-12 col-sm-12">
<h2 class="text-center">About SPLS</h2>

The <a href="http://www.dcs.gla.ac.uk/research/spls/">Scottish Programming Languages Seminar</a> (SPLS) is a venue for discussion of all aspects of programming languages. This includes theory, implementation and design. SPLS has a long lineage of meetings, going back to 2004. The host of the meeting cycles between several Scottish universities. This is the first time it shall be held at the <a href="https://www.uws.ac.uk/home/">University of the West of Scotland</a>, at its Paisley campus. This upcoming meeting shall be held on the 26th of June. 
</br>
</br>
For further information on SPLS meetings and activites apply to the <a href="https://mr1.dcs.gla.ac.uk/mailman/listinfo/spls">SPLS Mailing List</a>.  

<h2 class="text-center">Time and Location</h2>

This upcoming SPLS meeting will be held at the University of the West of Scotland's Paisley campus, from 12:00 until 17:30. It shall be hosted in the Paisley campuses F Block. You will be able to get refreshments room F124 and the talks will be held in room F113. 

</br>
</br> 
Travel information to the campus and the campus map can be found <a href="http://www.uws.ac.uk/about-uws/campuses/paisley/location-and-travel/">here</a>. 

<h2 class="text-center"> Registration </h2>

If you could please register using this <a href="https://beta.doodle.com/poll/9u2sinht8xwt3wk8#table">doodle poll</a>, so we can get an idea of numbers for food arrangements.
And if you have any dietary requirements please get in contact with one of the <a href="#organisers">organisers</a>. 

<h2 class="text-center"> Speakers </h2>

<h5><b>Nick Brown</b> - <i>An implementation of Python for the micro-core Epiphany co-processor</i></h5> 
<h5><b>Christopher Brown</b> - <i>TBD</i></h5>
<h5><b>Andrew Gozillon</b> - <i>Programmable address spaces</i></h5> 
<h5><b>Conor McBride</b> - <i>TBD</i></h5>
<h5><b>Michel Steuwer</b> - <i>Towards Composable GPU Programming: Programming GPUs with Eager Actions and Lazy Views</i></h5>
<h5><b>Rob Stewart</b> - <i>TBD</i></h5>
<h5><b>Thomas Wright</b> - <i>Process algebra meets cellular biology</i></h5> 


<!-- Should be done similar to http://www.dcs.gla.ac.uk/research/spls/Mar12/ or https://ff32.host.cs.st-andrews.ac.uk/spls/ as both look good !--> 
<h2 class="text-center">Programme</h2>
<table class="table table-striped">
<thead>
<tr>
<!--<th>Time</th> !-->
<th>Title / Speaker</th>
<th>Abstract</th>
</tr>
<thead>
<tbody>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Nick Brown</b></div><div><i>An implementation of Python for the micro-core Epiphany co-processor</i></div></td>
<td class="col-md-8" style="font-size:13px"> The Epiphany is a many-core, low power, low on-chip memory co-processor typical of a number of innovative micro-core architectures. The very low power nature of these architectures means that there is potential for their use in future HPC machines, and their low cost makes them ideal for HPC education & prototyping. However there is a high barrier to entry in programming due to the associated complexities and immaturity of supporting tools.</td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Andrew Gozillon</b></div><div><i>Programmable Address Spaces</i></div></td>
<td class="col-md-8" style="font-size:13px"> In the last decade, high-performance computing has made increasing use of heterogeneous many-core parallelism. Typically the individual processor cores within such a system are radically simpler than their predecessors; and an increased portion of the challenge in executing relevant programs efficiently is reassigned. Tasks, previously the responsibility of hardware, are now delegated to software. Fast, on-chip memory, will primarily be exposed within a series of trivially distinct programming languages, through a handful of address spaces annotations, which associate discrete sections of memory with pointers; or similar low-level abstractions. Traditional CPUs would provide a hardware data cache for such functionality. Our work aims to improve the programmability of address spaces by exposing new functionality within the existing template metaprogramming system of C++. This is achieved firstly via a new LLVM attribute, ext_address_space which facilitates integration with the non-type template parameters of C++. We also present a type traits API which encapsulates the address space annotations, to allow execution on both conventional and extended C++ compilers.</td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Thomas Wright</b></div><div><i>Process algebra meets cellular biology</i></div></td>
<td class="col-md-8" style="font-size:13px">Cells and concurrent programs are not so different - both have to communicate, process information, and respond to their environment. However, biological systems consist of many more agents than even the largest computer networks, and are highly heterogeneous with no apparent overall design, presenting formidable challenges in modelling and understanding their behaviour. Worse still, biologists don't have access to the high level programming languages we rely on in designing concurrent programs, instead working at the level of machine code (DNA) and circuit diagrams (protein signalling networks). This has inspired many to investigate ways to apply ideas from concurrent programming and process algebra to build higher level languages for modelling biochemical systems.
</br>
We propose a new high level concurrent programming language for modelling biological systems. We build upon the π-calculus, to model cells as communicating agents, and show how concepts such as parallel composition, name binding, and synchronisation correspond to concepts in biology. We apply our language to V. A. Kuznetsov's classic model of immune response to tumour growth, and show how we able capture complex features including by nonlinear interaction dynamics, n-party interactions, and dynamic binding of agents to form new agents.</td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Conor McBride</b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Christopher Brown</b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Rob Stewart</b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>
<tr>
<!--<td class="col-md-1"> 12:00 </td> !-->
<td class="col-md-3"> <div><b>Michel Steuwer</b></div><div><i>Towards Composable GPU Programming: Programming GPUs with Eager Actions and Lazy Views</i></div></td>
<td class="col-md-8" style="font-size:13px"> In this work, we advocate a composable approach to programming  systems with Graphics Processing Units (GPU): programs are developed as compositions of generic, reusable patterns. Current GPU programming approaches either rely on low-level, monolithic code without patterns (CUDA and OpenCL), which achieves
high performance at the cost of cumbersome and error-prone programming, or
they improve the programmability by using pattern-based abstractions (e.g.,
Thrust) but pay a performance penalty due to inefficient implementations of
pattern composition.
</br>
We develop an API for GPUs based programming on C++ with STL-style patterns
and its compiler-based implementation. Our API gives the application developers
the native C++ means (views and actions) to specify precisely which pattern
compositions should be automatically fused during code generation into a single
efficient GPU kernel, thereby ensuring a high target performance. We implement
our approach by extending the range-v3 library which is currently being developed
for the forthcoming C++ standards. The composable programming in our approach
is done exclusively in the standard C++14, with STL algorithms used as patterns
which we re-implemented in parallel for GPU. Our compiler implementation is
based on the LLVM and Clang frameworks, and we use advanced multi-stage
programming techniques for aggressive runtime optimizations.
</br>
We experimentally evaluate our approach using a set of benchmark applications and
a real-world case study from the area of image processing. Our codes achieve
performance competitive with CUDA monolithic implementations, and we
outperform pattern-based codes written using Nvidia’s Thrust.</td>
</tr>
</tbody>
</table>

<h2 class="text-center">Acknowledgement</h2>

This meeting of SPLS has been supported by the <a href="http://www.sicsa.ac.uk/research/theory-modelling-computation/">Theory, Modelling and Computation</a> theme of the <a href="http://www.sicsa.ac.uk/">Scottish Informatics and Computer Science Alliance (SICSA).</a> 

<h2 class="text-center"> Organisers </h2> <a name="organisers"></a>

Paul Keir, <a href="mailto:Paul.Keir@uws.ac.uk">Paul.Keir@uws.ac.uk</a> 
</br>
Andrew Gozillon, <a href="mailto:Andrew.Gozillon@uws.ac.uk">Andrew.Gozillon@uws.ac.uk</a> 
</div>
</div>
</body>

</html>
